/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘           MEDACTION - BUSINESS LOGIC EXPLOITATION AUDIT                                          â•‘
 * â•‘              Workflow Bypass | Race Conditions | State Manipulation                              â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  Tests: Workflow bypass, Mass Assignment, Boundary, Null exploitation, Race conditions          â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Run: npx tsx business-logic-exploit.ts
 */

const BASE_URL = 'http://localhost:3000';

const C = {
  r: '\x1b[0m', b: '\x1b[1m', dim: '\x1b[2m',
  red: '\x1b[31m', grn: '\x1b[32m', yel: '\x1b[33m',
  blu: '\x1b[34m', mag: '\x1b[35m', cyn: '\x1b[36m',
  bgRed: '\x1b[41m', bgGrn: '\x1b[42m',
};

interface TestResult {
  category: string;
  test: string;
  pass: boolean;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
  evidence: string;
  poc?: string;
}

const results: TestResult[] = [];

// HTTP Helper
async function http(url: string, opt: RequestInit = {}): Promise<{ st: number; body: string; json: any; tm: number }> {
  const start = Date.now();
  try {
    const res = await fetch(`${BASE_URL}${url}`, {
      ...opt,
      headers: { 'Content-Type': 'application/json', ...(opt.headers as any || {}) },
    });
    const body = await res.text();
    let json = null; try { json = JSON.parse(body); } catch {}
    return { st: res.status, body, json, tm: Date.now() - start };
  } catch {
    return { st: 0, body: '', json: null, tm: Date.now() - start };
  }
}

function log(category: string, test: string, pass: boolean, severity: TestResult['severity'], evidence: string, poc?: string) {
  const icon = pass ? `${C.grn}âœ“${C.r}` : `${C.red}âœ—${C.r}`;
  console.log(`  ${icon} [${severity}] ${test}`);
  if (!pass) console.log(`    ${C.yel}â†’ ${evidence}${C.r}`);
  results.push({ category, test, pass, severity, evidence, poc });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. WORKFLOW BYPASS - RÃ‰CLAMATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testReclamationWorkflow() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [1] WORKFLOW BYPASS - RÃ‰CLAMATIONS${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Skip workflow - directly set AFFECTEE status without ACCEPTEE
  let r = await http('/api/reclamations/1', {
    method: 'PATCH',
    body: JSON.stringify({ statut: 'AFFECTEE' })
  });
  log('Reclamation Workflow', 'Skip to AFFECTEE without ACCEPTEE', r.st !== 200, 
    r.st === 200 ? 'CRITICAL' : 'INFO',
    r.st === 200 ? 'Workflow bypassed!' : `Blocked with status ${r.st}`);

  // Test: Self-assignment (user affecting their own reclamation)
  r = await http('/api/reclamations/1/affecter', {
    method: 'PATCH',
    body: JSON.stringify({ autoriteId: 1, commentaire: 'Self-assign attempt' })
  });
  log('Reclamation Workflow', 'Self-assign reclamation', r.st !== 200,
    r.st === 200 ? 'HIGH' : 'INFO',
    r.st === 200 ? 'Self-assignment allowed!' : `Protected: ${r.st}`);

  // Test: Mark as resolved without being assigned
  r = await http('/api/reclamations/1/resoudre', {
    method: 'PATCH',
    body: JSON.stringify({ solution: 'Test solution', commentaire: 'Resolved without assignment' })
  });
  log('Reclamation Workflow', 'Resolve without assignment', r.st !== 200,
    r.st === 200 ? 'HIGH' : 'INFO',
    r.st === 200 ? 'Resolved without proper workflow!' : `Protected: ${r.st}`);

  // Test: Directly set RESOLUE via PATCH (bypass workflow)
  r = await http('/api/reclamations/1', {
    method: 'PATCH',
    body: JSON.stringify({ statut: 'RESOLUE' })
  });
  log('Reclamation Workflow', 'Direct RESOLUE via PATCH', r.st !== 200,
    r.st === 200 ? 'CRITICAL' : 'INFO',
    r.st === 200 ? 'Status manipulation possible!' : `Protected: ${r.st}`);

  // Test: Replay acceptance multiple times
  const acceptances = await Promise.all([
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'ACCEPTEE' }) }),
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'ACCEPTEE' }) }),
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'ACCEPTEE' }) }),
  ]);
  const multiAccept = acceptances.filter(a => a.st === 200).length;
  log('Reclamation Workflow', 'Multiple acceptance replay', multiAccept <= 1,
    multiAccept > 1 ? 'MEDIUM' : 'INFO',
    `${multiAccept} successful acceptances`);

  // Test: Race condition on assignment
  const assignments = await Promise.all([
    http('/api/reclamations/1/affecter', { method: 'PATCH', body: JSON.stringify({ autoriteId: 1 }) }),
    http('/api/reclamations/1/affecter', { method: 'PATCH', body: JSON.stringify({ autoriteId: 2 }) }),
    http('/api/reclamations/1/affecter', { method: 'PATCH', body: JSON.stringify({ autoriteId: 3 }) }),
  ]);
  const successAssign = assignments.filter(a => a.st === 200).length;
  log('Reclamation Workflow', 'Race condition on assignment', successAssign <= 1,
    successAssign > 1 ? 'MEDIUM' : 'INFO',
    `${successAssign} concurrent assignments succeeded`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. WORKFLOW BYPASS - Ã‰VÃ‰NEMENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testEvenementWorkflow() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [2] WORKFLOW BYPASS - Ã‰VÃ‰NEMENTS${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Self-validate event without admin
  let r = await http('/api/evenements/1/valider', {
    method: 'PATCH',
    body: JSON.stringify({ action: 'VALIDER', commentaire: 'Self-validation attempt' })
  });
  log('Evenement Workflow', 'Self-validate without admin', r.st !== 200,
    r.st === 200 ? 'CRITICAL' : 'INFO',
    r.st === 200 ? 'Self-validation allowed!' : `Protected: ${r.st}`);

  // Test: Skip EN_ATTENTE_VALIDATION to EN_ACTION
  r = await http('/api/evenements/1/statut', {
    method: 'PATCH',
    body: JSON.stringify({ statut: 'EN_ACTION' })
  });
  log('Evenement Workflow', 'Skip validation to EN_ACTION', r.st !== 200,
    r.st === 200 ? 'HIGH' : 'INFO',
    r.st === 200 ? 'Validation bypassed!' : `Protected: ${r.st}`);

  // Test: Directly publish without validation
  r = await http('/api/evenements/1', {
    method: 'PATCH',
    body: JSON.stringify({ statut: 'PUBLIEE' })
  });
  log('Evenement Workflow', 'Direct publish without validation', r.st !== 200,
    r.st === 200 ? 'CRITICAL' : 'INFO',
    r.st === 200 ? 'Published without approval!' : `Protected: ${r.st}`);

  // Test: Modify event after validation
  r = await http('/api/evenements/1', {
    method: 'PATCH',
    body: JSON.stringify({ titre: 'Modified after validation', description: 'Tampered content' })
  });
  log('Evenement Workflow', 'Modify after validation', r.st !== 200,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    r.st === 200 ? 'Post-validation modification allowed!' : `Protected: ${r.st}`);

  // Test: Close another user's event
  r = await http('/api/evenements/1/statut', {
    method: 'PATCH',
    body: JSON.stringify({ statut: 'CLOTUREE' })
  });
  log('Evenement Workflow', 'Close other user event', r.st !== 200,
    r.st === 200 ? 'HIGH' : 'INFO',
    r.st === 200 ? 'Unauthorized closure!' : `Protected: ${r.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. MASS ASSIGNMENT EXPLOIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testMassAssignment() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [3] MASS ASSIGNMENT EXPLOIT${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Register with role injection
  let r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({
      email: `massassign${Date.now()}@test.com`,
      password: 'Test123!@#$',
      nom: 'Mass',
      prenom: 'Assign',
      role: 'SUPER_ADMIN'
    })
  });
  const createdRole = r.json?.data?.user?.role || r.json?.user?.role;
  log('Mass Assignment', 'Role injection in registration', 
    createdRole !== 'SUPER_ADMIN' && createdRole !== 'ADMIN',
    createdRole === 'SUPER_ADMIN' ? 'CRITICAL' : 'INFO',
    `Created with role: ${createdRole || 'CITOYEN'}`);

  // Test: Register with isActive/isEmailVerifie
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({
      email: `massassign2${Date.now()}@test.com`,
      password: 'Test123!@#$',
      nom: 'Mass',
      prenom: 'Assign',
      isActive: true,
      isEmailVerifie: true,
      isSuperAdmin: true
    })
  });
  log('Mass Assignment', 'Inject isActive/isEmailVerifie', r.st === 400 || r.st === 429,
    r.st === 200 ? 'HIGH' : 'INFO',
    `Status: ${r.st}, extra fields ignored or blocked`);

  // Test: Update user with role change
  r = await http('/api/users/me', {
    method: 'PATCH',
    body: JSON.stringify({
      nom: 'Test',
      prenom: 'User',
      role: 'ADMIN'
    })
  });
  log('Mass Assignment', 'Self-promote via PATCH /users/me', r.st !== 200,
    r.st === 200 ? 'CRITICAL' : 'INFO',
    `Status: ${r.st}`);

  // Test: Inject ID in creation
  r = await http('/api/reclamations', {
    method: 'POST',
    body: JSON.stringify({
      id: 999999,
      sujet: 'Test ID injection',
      description: 'Trying to control ID',
      categorieId: 1
    })
  });
  log('Mass Assignment', 'ID injection in creation', true,
    'INFO',
    r.st === 201 ? 'Created with auto-ID (safe)' : `Status: ${r.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. BOUNDARY TESTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testBoundaries() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [4] BOUNDARY TESTING${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Minimum length (1 char)
  let r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({
      email: `b${Date.now()}@test.com`,
      password: 'Test123!@#$',
      nom: 'A', // Too short
      prenom: 'B' // Too short
    })
  });
  log('Boundary', 'Minimum name length (1 char)', r.st === 400,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    r.st === 400 ? 'Validation works' : `Accepted: ${r.st}`);

  // Test: Maximum length (10000 chars)
  const longString = 'A'.repeat(10000);
  r = await http('/api/reclamations', {
    method: 'POST',
    body: JSON.stringify({
      sujet: longString,
      description: longString,
      categorieId: 1
    })
  });
  log('Boundary', 'Max length (10000 chars)', r.st !== 200,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    r.st === 200 ? 'No length limit!' : `Blocked: ${r.st}`);

  // Test: Negative numbers
  r = await http('/api/evaluations', {
    method: 'POST',
    body: JSON.stringify({
      etablissementId: 1,
      note: -5, // Negative rating
      commentaire: 'Negative test'
    })
  });
  log('Boundary', 'Negative rating (-5)', r.st === 400,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    r.st === 400 ? 'Validation works' : `Accepted: ${r.st}`);

  // Test: Rating > 5
  r = await http('/api/evaluations', {
    method: 'POST',
    body: JSON.stringify({
      etablissementId: 1,
      note: 999,
      commentaire: 'Over max test'
    })
  });
  log('Boundary', 'Rating over max (999)', r.st === 400,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    r.st === 400 ? 'Validation works' : `Accepted: ${r.st}`);

  // Test: Integer overflow
  r = await http('/api/etablissements/9999999999999999999', {
    method: 'GET'
  });
  log('Boundary', 'Integer overflow ID', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    r.st === 500 ? 'Server crash!' : `Handled: ${r.st}`);

  // Test: Float as ID
  r = await http('/api/etablissements/1.5', { method: 'GET' });
  log('Boundary', 'Float ID (1.5)', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    r.st === 500 ? 'Server crash!' : `Handled: ${r.st}`);

  // Test: Pagination extremes
  r = await http('/api/etablissements?page=-1&limit=-10', { method: 'GET' });
  log('Boundary', 'Negative pagination', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  r = await http('/api/etablissements?page=0&limit=0', { method: 'GET' });
  log('Boundary', 'Zero pagination', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  r = await http('/api/etablissements?page=1&limit=999999', { method: 'GET' });
  const dataCount = r.json?.data?.length || 0;
  log('Boundary', 'Excessive pagination limit', dataCount <= 100,
    dataCount > 1000 ? 'MEDIUM' : 'INFO',
    `Returned ${dataCount} items`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. NULL/UNDEFINED EXPLOITATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testNullExploitation() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [5] NULL/UNDEFINED EXPLOITATION${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Null email
  let r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: null, password: 'Test123!@#$', nom: 'Test', prenom: 'User' })
  });
  log('Null Exploitation', 'Null email', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Null password
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: `null${Date.now()}@test.com`, password: null, nom: 'Test', prenom: 'User' })
  });
  log('Null Exploitation', 'Null password', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: All null
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: null, password: null, nom: null, prenom: null })
  });
  log('Null Exploitation', 'All null fields', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Empty object
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({})
  });
  log('Null Exploitation', 'Empty object', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Undefined-like strings
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: 'undefined', password: 'undefined', nom: 'null', prenom: 'NaN' })
  });
  log('Null Exploitation', 'String null/undefined', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Array instead of string
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: ['test@test.com'], password: ['Test123!'], nom: ['Test'], prenom: ['User'] })
  });
  log('Null Exploitation', 'Array instead of string', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Object instead of string
  r = await http('/api/auth/register', {
    method: 'POST',
    body: JSON.stringify({ email: {value: 'test@test.com'}, password: 'Test123!@#$', nom: 'Test', prenom: 'User' })
  });
  log('Null Exploitation', 'Object instead of string', r.st === 400,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. TYPE CONFUSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testTypeConfusion() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [6] TYPE CONFUSION${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: String vs Number ID
  let r1 = await http('/api/etablissements/1', { method: 'GET' });
  let r2 = await http('/api/etablissements/"1"', { method: 'GET' });
  log('Type Confusion', 'String ID ("1") vs Number ID (1)', 
    r2.st === 404 || r2.st === 400,
    r2.st === 200 ? 'LOW' : 'INFO',
    `Number: ${r1.st}, String: ${r2.st}`);

  // Test: Boolean as string
  r1 = await http('/api/etablissements?isPublie=true', { method: 'GET' });
  r2 = await http('/api/etablissements?isPublie="true"', { method: 'GET' });
  log('Type Confusion', 'Boolean as string', true, 'INFO',
    `true: ${r1.st}, "true": ${r2.st}`);

  // Test: Number as string in body
  let r = await http('/api/evaluations', {
    method: 'POST',
    body: JSON.stringify({ etablissementId: "1", note: "5", commentaire: 'Type test' })
  });
  log('Type Confusion', 'Numeric strings in body', r.st !== 500,
    r.st === 500 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Boolean in numeric field
  r = await http('/api/evaluations', {
    method: 'POST',
    body: JSON.stringify({ etablissementId: true, note: false, commentaire: 'Boolean test' })
  });
  log('Type Confusion', 'Boolean in numeric fields', r.st === 400,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 7. RACE CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testRaceConditions() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [7] RACE CONDITIONS${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Concurrent registration with same email
  const email = `race${Date.now()}@test.com`;
  const regBody = JSON.stringify({ email, password: 'Test123!@#$', nom: 'Race', prenom: 'Test' });
  const registrations = await Promise.all([
    http('/api/auth/register', { method: 'POST', body: regBody }),
    http('/api/auth/register', { method: 'POST', body: regBody }),
    http('/api/auth/register', { method: 'POST', body: regBody }),
  ]);
  const successReg = registrations.filter(r => r.st === 201).length;
  log('Race Condition', 'Duplicate registration', successReg <= 1,
    successReg > 1 ? 'HIGH' : 'INFO',
    `${successReg} registrations with same email succeeded`);

  // Test: Concurrent status updates
  const statusUpdates = await Promise.all([
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'ACCEPTEE' }) }),
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'REJETEE' }) }),
    http('/api/reclamations/1/statut', { method: 'PATCH', body: JSON.stringify({ statut: 'EN_COURS' }) }),
  ]);
  const conflictStatus = statusUpdates.filter(r => r.st === 200).length;
  log('Race Condition', 'Concurrent status updates', conflictStatus <= 1,
    conflictStatus > 1 ? 'MEDIUM' : 'INFO',
    `${conflictStatus} concurrent updates succeeded`);

  // Test: Concurrent file uploads (quota)
  const uploadPromises = Array.from({ length: 10 }, () =>
    http('/api/upload', { method: 'POST', body: JSON.stringify({ filename: 'test.jpg' }) })
  );
  const uploads = await Promise.all(uploadPromises);
  const successUploads = uploads.filter(r => r.st === 200 || r.st === 201).length;
  log('Race Condition', 'Concurrent uploads (quota bypass)', successUploads <= 5,
    successUploads > 5 ? 'MEDIUM' : 'INFO',
    `${successUploads}/10 concurrent uploads succeeded`);

  // Test: Double submission
  const submissionBody = JSON.stringify({
    sujet: `Double${Date.now()}`,
    description: 'Double submission test',
    categorieId: 1
  });
  const submissions = await Promise.all([
    http('/api/reclamations', { method: 'POST', body: submissionBody }),
    http('/api/reclamations', { method: 'POST', body: submissionBody }),
  ]);
  const successSub = submissions.filter(r => r.st === 201).length;
  log('Race Condition', 'Double form submission', true, 'INFO',
    `${successSub} duplicate submissions (check if duplicates allowed)`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 8. PERMISSION LOGIC FLAWS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testPermissionFlaws() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [8] PERMISSION LOGIC FLAWS${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Read-only role performing writes
  const writeOps = [
    { method: 'POST', path: '/api/etablissements', body: { nom: 'Test', code: 'TEST001', communeId: 1 } },
    { method: 'PATCH', path: '/api/etablissements/1', body: { nom: 'Modified' } },
    { method: 'DELETE', path: '/api/etablissements/1', body: {} },
    { method: 'POST', path: '/api/admin/users', body: { email: 'new@test.com', password: 'Test123!@#$', nom: 'New', prenom: 'User', role: 'CITOYEN' } },
  ];

  for (const op of writeOps) {
    const r = await http(op.path, { method: op.method, body: JSON.stringify(op.body) });
    log('Permission Flaws', `${op.method} ${op.path.replace(/\/\d+/g, '/:id')}`, 
      r.st === 401 || r.st === 403,
      r.st === 200 || r.st === 201 ? 'CRITICAL' : 'INFO',
      `Status: ${r.st}`);
  }

  // Test: Access other user's data
  const r = await http('/api/users/1', { method: 'GET' });
  log('Permission Flaws', 'Access other user profile', 
    r.st === 401 || r.st === 403,
    r.st === 200 ? 'MEDIUM' : 'INFO',
    `Status: ${r.st}`);

  // Test: Mass data export (scraping)
  const exportR = await http('/api/export/excel?type=users', { method: 'GET' });
  log('Permission Flaws', 'Export all users data', 
    exportR.st === 401 || exportR.st === 403,
    exportR.st === 200 ? 'HIGH' : 'INFO',
    `Status: ${exportR.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 9. ACCOUNT LOCKOUT BYPASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testLockoutBypass() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [9] ACCOUNT LOCKOUT BYPASS${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Test: Check if lockout is enforced
  const checkR = await http('/api/auth/login-check', { method: 'POST' });
  const isLocked = checkR.json?.blocked || checkR.st === 429;
  log('Lockout Bypass', 'IP-based lockout active', isLocked || checkR.st === 200,
    'INFO',
    isLocked ? 'Currently locked out' : `Login check allowed: ${checkR.st}`);

  // Test: Different user-agent bypass
  const r = await http('/api/auth/login-check', {
    method: 'POST',
    headers: { 'User-Agent': 'Mozilla/5.0 BypassBot' }
  });
  log('Lockout Bypass', 'User-Agent bypass', r.st !== 200 || r.json?.blocked,
    r.st === 200 && !r.json?.blocked ? 'HIGH' : 'INFO',
    `Status: ${r.st}, Blocked: ${r.json?.blocked}`);

  // Test: X-Forwarded-For bypass
  const forwardedR = await http('/api/auth/login-check', {
    method: 'POST',
    headers: { 'X-Forwarded-For': '203.0.113.50' }
  });
  log('Lockout Bypass', 'X-Forwarded-For bypass', 
    forwardedR.st !== 200 || forwardedR.json?.blocked,
    forwardedR.st === 200 && !forwardedR.json?.blocked ? 'CRITICAL' : 'INFO',
    `Status: ${forwardedR.st}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 10. TOKEN PREDICTABILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function testTokenPredictability() {
  console.log(`\n${C.b}${C.mag}${'â•'.repeat(70)}${C.r}`);
  console.log(`${C.b}${C.mag}  [10] TOKEN PREDICTABILITY${C.r}`);
  console.log(`${C.b}${C.mag}${'â•'.repeat(70)}${C.r}\n`);

  // Generate multiple password reset tokens
  const tokens: string[] = [];
  for (let i = 0; i < 5; i++) {
    const r = await http('/api/auth/forgot-password', {
      method: 'POST',
      body: JSON.stringify({ email: `token${i}@test.com` })
    });
    if (r.json?.token) tokens.push(r.json.token);
    await new Promise(r => setTimeout(r, 100));
  }

  // Analyze tokens for patterns
  if (tokens.length > 1) {
    const allHex = tokens.every(t => /^[a-f0-9]+$/i.test(t));
    const allSameLength = tokens.every(t => t.length === tokens[0].length);
    const sequential = tokens.some((t, i) => i > 0 && parseInt(t, 16) === parseInt(tokens[i-1], 16) + 1);
    
    log('Token Predictability', 'Password reset tokens', !sequential,
      sequential ? 'CRITICAL' : 'INFO',
      `${tokens.length} tokens collected, sequential: ${sequential}`);
  } else {
    log('Token Predictability', 'Password reset tokens', true, 'INFO',
      'Tokens not exposed in response (secure design)');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function main() {
  console.log(`
${C.b}${C.mag}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BUSINESS LOGIC EXPLOITATION AUDIT - MEDACTION                                           â•‘
â•‘              Workflow Bypass | Race Conditions | Mass Assignment | Boundary Testing              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.r}
`);

  // Health check
  const health = await http('/api/health');
  if (health.st === 0) {
    console.log(`${C.red}âœ— Server not running${C.r}`);
    process.exit(1);
  }
  console.log(`${C.grn}âœ“ Server accessible${C.r}`);

  await testReclamationWorkflow();
  await testEvenementWorkflow();
  await testMassAssignment();
  await testBoundaries();
  await testNullExploitation();
  await testTypeConfusion();
  await testRaceConditions();
  await testPermissionFlaws();
  await testLockoutBypass();
  await testTokenPredictability();

  // Final Report
  const passed = results.filter(r => r.pass).length;
  const failed = results.filter(r => !r.pass).length;
  const critical = results.filter(r => !r.pass && r.severity === 'CRITICAL').length;
  const high = results.filter(r => !r.pass && r.severity === 'HIGH').length;
  const medium = results.filter(r => !r.pass && r.severity === 'MEDIUM').length;

  console.log(`
${C.b}${C.mag}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         BUSINESS LOGIC AUDIT FINAL REPORT                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Total Tests: ${results.length.toString().padEnd(10)} | Passed: ${passed.toString().padEnd(5)} | Failed: ${failed}                                          â•‘
â•‘  ğŸ”´ CRITICAL: ${critical.toString().padEnd(5)} | ğŸŸ  HIGH: ${high.toString().padEnd(5)} | ğŸŸ¡ MEDIUM: ${medium}                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.r}
`);

  if (critical === 0 && high === 0) {
    console.log(`${C.bgGrn}${C.b}  âœ… NO CRITICAL BUSINESS LOGIC FLAWS FOUND  ${C.r}\n`);
  } else {
    console.log(`${C.bgRed}${C.b}  âš ï¸ BUSINESS LOGIC VULNERABILITIES FOUND - REVIEW REQUIRED  ${C.r}\n`);
    
    const vulns = results.filter(r => !r.pass && (r.severity === 'CRITICAL' || r.severity === 'HIGH'));
    console.log(`${C.b}Critical Issues:${C.r}`);
    for (const v of vulns) {
      console.log(`  [${v.severity}] ${v.category} - ${v.test}`);
      console.log(`    ${C.yel}${v.evidence}${C.r}`);
    }
  }
}

main().catch(console.error);
