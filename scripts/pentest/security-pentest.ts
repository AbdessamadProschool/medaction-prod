/**
 * =========================================================
 * SCRIPT DE TESTS DE SÉCURITÉ COMPLET - MedAction
 * =========================================================
 * Ce script effectue des tests de pénétration simulés sur l'API
 * Author: Antigravity Security Scanner
 * Date: 2025-12-16
 */

const BASE_URL = 'http://localhost:3000';

// Couleurs pour le terminal
const C = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m',
};

interface TestResult {
  name: string;
  category: string;
  passed: boolean;
  status?: number;
  details?: string;
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'info';
}

const results: TestResult[] = [];

async function runTest(
  name: string,
  category: string,
  fn: () => Promise<{ passed: boolean; status?: number; details?: string }>,
  severity: TestResult['severity'] = 'medium'
) {
  process.stdout.write(`  ${C.cyan}⏳${C.reset} ${name}...`);
  try {
    const result = await fn();
    results.push({ name, category, severity, ...result });
    if (result.passed) {
      console.log(`\r  ${C.green}✓${C.reset} ${name}`);
    } else {
      console.log(`\r  ${C.red}✗${C.reset} ${name} - ${result.details || ''}`);
    }
  } catch (err: any) {
    results.push({ 
      name, 
      category, 
      passed: false, 
      details: err.message, 
      severity 
    });
    console.log(`\r  ${C.red}✗${C.reset} ${name} - ERROR: ${err.message}`);
  }
}

async function fetchApi(
  url: string, 
  options: RequestInit = {}
): Promise<Response | null> {
  try {
    return await fetch(`${BASE_URL}${url}`, {
      ...options,
      headers: { 'Content-Type': 'application/json', ...(options.headers || {}) },
    });
  } catch (err) {
    return null;
  }
}

// =========================================================
// TESTS D'AUTHENTIFICATION
// =========================================================
async function testAuthentication() {
  console.log(`\n${C.bold}${C.magenta}[1] TESTS D'AUTHENTIFICATION${C.reset}`);
  
  await runTest('Routes Admin protégées', 'auth', async () => {
    const res = await fetchApi('/api/admin/logs');
    return {
      passed: res?.status === 401 || res?.status === 403,
      status: res?.status,
      details: res?.status === 200 ? 'CRITIQUE: Route admin accessible!' : undefined,
    };
  }, 'critical');

  await runTest('Routes Super Admin protégées', 'auth', async () => {
    const res = await fetchApi('/api/admins');
    return {
      passed: res?.status === 401 || res?.status === 403,
      status: res?.status,
    };
  }, 'critical');

  await runTest('API Permissions protégée', 'auth', async () => {
    const res = await fetchApi('/api/permissions');
    return {
      passed: res?.status === 401 || res?.status === 403,
      status: res?.status,
    };
  }, 'critical');

  await runTest('API Reclamations POST protégée', 'auth', async () => {
    const res = await fetchApi('/api/reclamations', {
      method: 'POST',
      body: JSON.stringify({ titre: 'Test', description: 'Test' }),
    });
    return {
      passed: res?.status === 401,
      status: res?.status,
    };
  }, 'high');
}

// =========================================================
// TESTS D'INJECTION SQL
// =========================================================
async function testSQLInjection() {
  console.log(`\n${C.bold}${C.magenta}[2] TESTS D'INJECTION SQL${C.reset}`);
  
  const payloads = [
    "' OR '1'='1",
    "1; DROP TABLE users--",
    "' UNION SELECT * FROM users--",
    "admin'--",
    "1' OR '1' = '1",
  ];

  for (const payload of payloads) {
    await runTest(`SQL Injection: ${payload.substring(0, 20)}...`, 'sqli', async () => {
      const res = await fetchApi(`/api/etablissements?search=${encodeURIComponent(payload)}`);
      // Si on reçoit 500, c'est potentiellement vulnérable
      return {
        passed: res !== null && res.status !== 500,
        status: res?.status,
        details: res?.status === 500 ? 'CRITIQUE: Erreur serveur sur injection SQL!' : undefined,
      };
    }, 'critical');
  }
}

// =========================================================
// TESTS XSS (Cross-Site Scripting)
// =========================================================
async function testXSS() {
  console.log(`\n${C.bold}${C.magenta}[3] TESTS XSS${C.reset}`);
  
  const xssPayloads = [
    '<script>alert(1)</script>',
    '<img src=x onerror=alert(1)>',
    '"><script>alert(document.cookie)</script>',
    "javascript:alert('XSS')",
    '<svg onload=alert(1)>',
  ];

  for (const payload of xssPayloads) {
    await runTest(`XSS: ${payload.substring(0, 25)}...`, 'xss', async () => {
      const res = await fetchApi(`/api/etablissements?search=${encodeURIComponent(payload)}`);
      const text = await res?.text();
      // Vérifier si le payload est renvoyé sans échappement
      const hasXSS = text?.includes(payload) && !text?.includes('&lt;');
      return {
        passed: !hasXSS,
        status: res?.status,
        details: hasXSS ? 'ATTENTION: Payload XSS potentiellement reflété!' : undefined,
      };
    }, 'high');
  }
}

// =========================================================
// TESTS DE CONTRÔLE D'ACCÈS
// =========================================================
async function testAccessControl() {
  console.log(`\n${C.bold}${C.magenta}[4] TESTS CONTRÔLE D'ACCÈS${C.reset}`);
  
  // Routes sensibles qui doivent être protégées
  const sensitiveRoutes = [
    { path: '/api/admin/logs', method: 'GET' },
    { path: '/api/admin/stats', method: 'GET' },
    { path: '/api/admins', method: 'GET' },
    { path: '/api/permissions', method: 'GET' },
    { path: '/api/admin/notifications', method: 'GET' },
    { path: '/api/backup/create', method: 'POST' },
  ];

  for (const route of sensitiveRoutes) {
    await runTest(`Accès ${route.method} ${route.path}`, 'access', async () => {
      const res = await fetchApi(route.path, { method: route.method });
      return {
        passed: res?.status === 401 || res?.status === 403 || res?.status === 404,
        status: res?.status,
        details: res?.status === 200 ? 'CRITIQUE: Route accessible sans authentification!' : undefined,
      };
    }, 'critical');
  }
}

// =========================================================
// TESTS ENDPOINTS PUBLICS
// =========================================================
async function testPublicEndpoints() {
  console.log(`\n${C.bold}${C.magenta}[5] TESTS ENDPOINTS PUBLICS${C.reset}`);
  
  const publicRoutes = [
    '/api/map/etablissements',
    '/api/map/communes',
    '/api/etablissements',
    '/api/evenements',
    '/api/maintenance',
  ];

  for (const route of publicRoutes) {
    await runTest(`Endpoint public ${route}`, 'public', async () => {
      const res = await fetchApi(route);
      return {
        passed: res !== null && (res.status === 200 || res.status === 401),
        status: res?.status,
        details: res === null ? 'Serveur injoignable' : undefined,
      };
    }, 'info');
  }
}

// =========================================================
// TESTS RATE LIMITING
// =========================================================
async function testRateLimiting() {
  console.log(`\n${C.bold}${C.magenta}[6] TESTS RATE LIMITING${C.reset}`);
  
  await runTest('Rate Limit (20 requêtes rapides)', 'ratelimit', async () => {
    const requests = Array(20).fill(0).map(() => fetchApi('/api/map/etablissements'));
    const responses = await Promise.all(requests);
    const blocked = responses.filter(r => r?.status === 429).length;
    return {
      passed: true, // Info seulement
      status: blocked > 0 ? 429 : 200,
      details: blocked > 0 
        ? `Rate limiting actif: ${blocked}/20 bloquées`
        : `Aucune requête bloquée (Mode Dev normal)`,
    };
  }, 'info');
}

// =========================================================
// TESTS DE VALIDATION D'ENTRÉE
// =========================================================
async function testInputValidation() {
  console.log(`\n${C.bold}${C.magenta}[7] TESTS VALIDATION D'ENTRÉE${C.reset}`);
  
  await runTest('Rejet données malformées (POST)', 'validation', async () => {
    const res = await fetchApi('/api/reclamations', {
      method: 'POST',
      body: 'not-json',
    });
    return {
      passed: res?.status === 400 || res?.status === 401,
      status: res?.status,
    };
  }, 'medium');

  await runTest('Rejet ID invalide (lettre)', 'validation', async () => {
    const res = await fetchApi('/api/etablissements/abc');
    return {
      passed: res?.status !== 500,
      status: res?.status,
      details: res?.status === 500 ? 'Erreur serveur sur ID invalide' : undefined,
    };
  }, 'medium');

  await runTest('Rejet ID invalide (négatif)', 'validation', async () => {
    const res = await fetchApi('/api/etablissements/-1');
    return {
      passed: res?.status !== 500,
      status: res?.status,
    };
  }, 'medium');
}

// =========================================================
// GÉNÉRATION DU RAPPORT
// =========================================================
function generateReport() {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`${C.bold}${C.cyan}      RAPPORT DE SÉCURITÉ - MedAction${C.reset}`);
  console.log(`${'='.repeat(60)}`);
  console.log(`Date: ${new Date().toLocaleString('fr-FR')}`);
  console.log(`Serveur testé: ${BASE_URL}`);
  console.log();

  const categories = ['auth', 'sqli', 'xss', 'access', 'public', 'ratelimit', 'validation'];
  const categoryNames: Record<string, string> = {
    auth: 'Authentification',
    sqli: 'Injection SQL',
    xss: 'Cross-Site Scripting',
    access: 'Contrôle d\'Accès',
    public: 'Endpoints Publics',
    ratelimit: 'Rate Limiting',
    validation: 'Validation Entrée',
  };

  for (const cat of categories) {
    const catResults = results.filter(r => r.category === cat);
    if (catResults.length === 0) continue;

    const passed = catResults.filter(r => r.passed).length;
    const total = catResults.length;
    const icon = passed === total ? '✅' : (passed > 0 ? '⚠️' : '❌');
    
    console.log(`${icon} ${C.bold}${categoryNames[cat]}${C.reset}: ${passed}/${total} tests passés`);
  }

  // Résumé
  const totalPassed = results.filter(r => r.passed).length;
  const totalTests = results.length;
  const criticalFails = results.filter(r => !r.passed && r.severity === 'critical');
  
  console.log(`\n${'─'.repeat(60)}`);
  console.log(`${C.bold}RÉSUMÉ:${C.reset}`);
  console.log(`  Total: ${totalPassed}/${totalTests} tests passés (${Math.round(totalPassed/totalTests*100)}%)`);
  
  if (criticalFails.length > 0) {
    console.log(`  ${C.red}${C.bold}⚠ ${criticalFails.length} vulnérabilité(s) CRITIQUE(s) détectée(s)!${C.reset}`);
    for (const fail of criticalFails) {
      console.log(`    - ${fail.name}: ${fail.details || 'Échec'}`);
    }
  } else {
    console.log(`  ${C.green}${C.bold}✓ Aucune vulnérabilité critique détectée${C.reset}`);
  }

  // Score de sécurité
  const score = Math.round((totalPassed / totalTests) * 100);
  let grade = 'F';
  let gradeColor = C.red;
  if (score >= 90) { grade = 'A'; gradeColor = C.green; }
  else if (score >= 80) { grade = 'B'; gradeColor = C.green; }
  else if (score >= 70) { grade = 'C'; gradeColor = C.yellow; }
  else if (score >= 60) { grade = 'D'; gradeColor = C.yellow; }
  
  console.log(`\n${C.bold}SCORE DE SÉCURITÉ: ${gradeColor}${grade} (${score}%)${C.reset}`);
  console.log(`${'='.repeat(60)}\n`);
}

// =========================================================
// MAIN
// =========================================================
async function main() {
  console.log(`\n${C.bold}${C.blue}╔════════════════════════════════════════════════════════╗${C.reset}`);
  console.log(`${C.bold}${C.blue}║   MEDACTION - AUDIT DE SÉCURITÉ COMPLET                ║${C.reset}`);
  console.log(`${C.bold}${C.blue}╚════════════════════════════════════════════════════════╝${C.reset}`);
  console.log(`\nVérification de la connexion au serveur...`);
  
  const healthCheck = await fetchApi('/api/maintenance');
  if (!healthCheck) {
    console.log(`${C.red}✗ Impossible de contacter le serveur sur ${BASE_URL}${C.reset}`);
    console.log(`  Assurez-vous que le serveur est lancé avec: npm run dev`);
    process.exit(1);
  }
  console.log(`${C.green}✓ Serveur accessible${C.reset}`);

  await testAuthentication();
  await testSQLInjection();
  await testXSS();
  await testAccessControl();
  await testPublicEndpoints();
  await testRateLimiting();
  await testInputValidation();

  generateReport();
}

main().catch(console.error);
